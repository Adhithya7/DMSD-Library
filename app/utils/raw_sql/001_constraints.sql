CREATE OR REPLACE FUNCTION ins_borrow()
RETURNS trigger LANGUAGE plpgsql as $$
BEGIN
INSERT INTO BORROWING DEFAULT VALUES;
RETURN null;
END $$;

CREATE OR REPLACE FUNCTION del_reserve()
RETURNS trigger LANGUAGE plpgsql as $$
BEGIN
DELETE FROM RESERVATION
WHERE RES_NO in (SELECT RESERVATION_NO from RESERVES
JOIN I
ON I.DOCID = RESERVES.DOCID and I.COPYNO = RESERVES.COPYNO and I.BID = RESERVES.BID);
RETURN null;
END $$;

CREATE OR REPLACE FUNCTION abortOrInsert()
RETURNS trigger LANGUAGE plpgsql as $$
BEGIN
IF 10<= (SELECT count(*) from 
((SELECT BR.docid as docid, BR.copyno as copyno from BORROWS BR
JOIN BORROWING BS on BR.bor_no = BS.bor_no
and BS.rdtime is null and BR.rid = new.rid)
UNION ALL
(SELECT docid, copyno from RESERVES where rid = new.rid)) as tab2)
THEN RAISE EXCEPTION 'Reader has 10 active transactions already';
ELSEIF EXISTS (SELECT tab2.DOCID from 
((SELECT BR.DOCID from BORROWS BR
JOIN BORROWING BS on BR.bor_no = BS.bor_no
and BS.rdtime is null and BR.rid = new.rid and BR.docid = new.docid)
UNION
(SELECT docid from RESERVES where rid = new.rid and docid = new.docid)) as tab2)
THEN RAISE EXCEPTION 'Reader has reserved/borrowed a book with the same docid already';
ELSE
INSERT INTO RESERVATION DEFAULT VALUES;
END IF;
RETURN new;
END $$;

CREATE TRIGGER TOTAL_BOOKS_BORROWED
BEFORE INSERT ON RESERVES
FOR EACH STATEMENT
EXECUTE PROCEDURE abortOrInsert();

CREATE TRIGGER BORROWS
BEFORE INSERT ON BORROWS
FOR EACH STATEMENT
EXECUTE PROCEDURE ins_borrow();

CREATE TRIGGER DEL_RESERVE
AFTER INSERT ON BORROWS
REFERENCING NEW TABLE AS I
FOR EACH STATEMENT
EXECUTE PROCEDURE del_reserve();
